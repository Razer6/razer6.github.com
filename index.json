
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"I am currently a security architect at Rivos and working on the security subsystem. Before that, I worked as a security researcher in the Secure Systems (SESYS) group of Prof. Stefan Mangard, where I obtained my Ph.D. My research interests include protecting general purpose software against fault attacks. In particular, my research focuses on the hardware-software codesign, comprising the modification of processor cores and developing compiler support, e.g., LLVM integration.\n","date":1694044800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1694044800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I am currently a security architect at Rivos and working on the security subsystem. Before that, I worked as a security researcher in the Secure Systems (SESYS) group of Prof. Stefan Mangard, where I obtained my Ph.","tags":null,"title":"Robert Schilling","type":"authors"},{"authors":["Robert Schilling"],"categories":null,"content":"","date":1694044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1694044800,"objectID":"e585611785f6f30a5202db04258549de","permalink":"https://example.com/publication/20_thesis/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/20_thesis/","section":"publication","summary":"Software is ubiquitous in all applications of modern lives. The correct execution of software is essential for the functionality and security of the underlying device. Fault attacks undermine the correct software execution and therefore break the security of many devices. Attackers with physical proximity can induce faults and disrupt the correct operation. With recent research results, faults can even be induced via software remotely, bringing those attacks to even larger systems. Unfortunately, the current processors do not offer considerable support in safeguarding software execution from fault attacks.\nIn this thesis, we tackle the challenge of secure software execution in the presence of fault attacks from three perspectives. First, we look into this problem from an algorithmic and energy efficiency point of view. We analyze a hardware accelerator for fault- and side-channel secure cryptography. Instead of deploying redundancy-based protection against faults, we explore fresh re-keying as an algorithmic way of protection. The accelerator is deeply integrated into a multi-core System-on-Chip and provides fault-protected (authenticated) encryption with an energy budget of a few pJ/op. Then, we shift the perspective and analyze how a compiler-assisted approach can be used to protect arbitrary software against faults. We show that existing hardware primitives from the ARM instruction set architecture can be used to build a control-flow integrity (CFI) protection scheme against software- and fault-based control-flow attacks. By developing FIPAC, a basic block granular CFI protection scheme with full compiler support, we can protect software with different security guarantees against control-flow attacks. FIPAC is further the pillar to protect the system call interface of an operating system against faults. Eventually,  we solve the challenge of unprotected conditional branches in the presence of faults, even with deployed CFI. By designing a protected comparison that is linked to the CFI scheme, we inherently provide protection for security-critical conditional branches. Finally, we investigate the protection of memory accesses in the physical and virtual memory domain against fault attacks. With reasonable hardware and runtime overheads, we protect the memory subsystem of embedded- and application-class processors against faults. These mechanisms use the help of the compiler and can be automatically applied to arbitrary software. These developments show that a compiler-assisted hardware-software code design can lead to efficient and secure countermeasures for different performance profiles.","tags":["Source Themes"],"title":"Hardware Extensions and Compiler Support for Protection Against Fault Attacks","type":"publication"},{"authors":["Martin Unterguggenberger","David Schrammel","Pascal Nasahl","Robert Schilling","Lukas Lamster","Stefan Mangard"],"categories":null,"content":"","date":1681689600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1681689600,"objectID":"d9a698cc2a6d352f2268080029279a9b","permalink":"https://example.com/publication/19_multitag/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/19_multitag/","section":"publication","summary":"Memory safety vulnerabilities are a severe threat to modern computer systems allowing adversaries to leak or modify security-critical data. To protect systems from this attack vector, full memory safety is required. As software-based countermeasures tend to induce significant runtime overheads, which is not acceptable for production code, hardware assistance is needed. Tagged memory architectures, e.g., already offered by the ARM MTE and SPARC ADI extensions, assign meta-information to memory objects, thus allowing to implement memory safety policies. However, due to the high tag collision probability caused by the small tag sizes, the protection guarantees of these schemes are limited.\nThis paper presents Multi-Tag, the first hardware-software co-design utilizing a multi-granular tagging structure that provides strong protection against spatial and temporal memory safety violations. By combining object-granular memory tags with page-granular tags stored in the page table entries, Multi-Tag overcomes the limitation of small tag sizes. Introducing page-granular tags significantly enhances the probabilistic protection capabilities of memory tagging without increasing the memory overhead or the system's complexity. We develop a prototype implementation comprising a gem5 model of the tagged architecture, a Linux kernel extension, and an LLVM-based compiler toolchain. The simulated performance overhead for the SPEC CPU2017 and nbench-byte benchmarks highlights the practicability of our design.","tags":["Source Themes"],"title":"Multi-Tag: A Hardware-Software Co-Design for Memory Safety based on Multi-Granular Memory Tagging","type":"publication"},{"authors":["Pascal Nasahl","Martin Unterguggenberger","Rishub Nagpal","Robert Schilling","David Schrammel","Stefan Mangard"],"categories":null,"content":"","date":1680825600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680825600,"objectID":"2a3405356eff3fe5b73cfa04a4fe593c","permalink":"https://example.com/publication/18_scfi/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/18_scfi/","section":"publication","summary":"Fault injection (FI) is a powerful attack methodology allowing an adversary to entirely break the security of a target device. As finitestate machines (FSMs) are fundamental hardware building blocks responsible for controlling systems, inducing faults into these controllers enables an adversary to hijack the execution of the integrated circuit. A common defense strategy mitigating these attacks is to manually instantiate FSMs multiple times and detect faults using a majority voting logic. However, as each additional FSM instance only provides security against one additional induced fault, this approach scales poorly in a multi-fault attack scenario. In this paper, we present SCFI: a strong, probabilistic FSM protection mechanism ensuring that control-flow deviations from the intended control-flow are detected even in the presence of multiple faults. At its core, SCFI consists of a hardened next-state function absorbing the execution history as well as the FSM’s control signals to derive the next state. When either the absorbed inputs, the state registers, or the function itself are affected by faults, SCFI triggers an error with no detection latency. We integrate SCFI into a synthesis tool capable of automatically hardening arbitrary unprotected FSMs without user interaction and open-source the tool. Our evaluation shows that SCFI provides strong protection guarantees with a better area-time product than FSMs protected using classical redundancy-based approaches. Finally, we formally verify the resilience of the protected state machines using a pre-silicon fault analysis tool.","tags":["Source Themes"],"title":"SCFI: State Machine Control-Flow Hardening Against Fault Attacks","type":"publication"},{"authors":["Robert Schilling","Pascal Nasahl","Martin Unterguggenberger","Stefan Mangard"],"categories":null,"content":"","date":1665100800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1665100800,"objectID":"90b92caf669b1f9ce907ae38218a7732","permalink":"https://example.com/publication/17_sfp/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/17_sfp/","section":"publication","summary":"With the improvements in computing technologies, edge devices in the Internet-of-Things or the automotive area have become more complex. The enabler technology for these complex systems are powerful application core processors with operating system support, such as Linux, replacing simpler bare-metal systems. While the isolation of applications through the operating system increases the security, the interface to the kernel poses a new threat. Different attack vectors, including fault attacks and memory vulnerabilities, exploit the kernel interface to escalate privileges and take over the system. In this work, we present SFP, a mechanism to protect the execution of system calls against software and fault attacks providing integrity to user-kernel transitions. SFP provides system call flow integrity by a two-step linking approach, which links the system call and its origin to the state of control-flow integrity. A second linking step within the kernel ensures that the right system call is executed in the kernel. Combining both linking steps ensures that only the correct system call is executed at the right location in the program and cannot be skipped. Furthermore, SFP provides dynamic CFI instrumentation and a new CFI checking policy at the edge of the kernel to verify the control-flow state of user programs before entering the kernel. We integrated SFP into FIPAC, a CFI protection scheme exploiting ARM pointer authentication. Our prototype is based on a custom LLVM-based toolchain with an instrumented runtime library combined with a custom Linux kernel to protect system calls. The evaluation of micro- and macrobenchmarks based on SPEC 2017 show an average runtime overhead of 1.9 % and 20.6 %, which is only an increase of 1.8 % over plain control-flow protection. This small impact on the performance shows the efficiency of SFP for protecting all system calls and providing integrity for the user-kernel transitions.","tags":["Source Themes"],"title":"SFP: Providing System Call Flow Protection against Software and Fault Attacks","type":"publication"},{"authors":["Robert Schilling","Pascal Nasahl","Stefan Mangard"],"categories":null,"content":"","date":1649289600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1649289600,"objectID":"03217d3815c9d395052a36101ca0eab7","permalink":"https://example.com/publication/16_fipac/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/16_fipac/","section":"publication","summary":"With improvements in computing technology, more and more applications in the Internet-of-Things, mobile devices, or automotive area embed powerful ARM processors. These systems can be attacked by redirecting the control-flow to bypass critical pieces of code such as privilege checks or signature verifications or to perform other fault attacks on applications or security mechanisms like secure boot. Control-flow hijacks can be performed using classical software vulnerabilities, physical fault attacks, or software-induced faults. To cope with this threat and to protect the control-flow, dedicated countermeasures are needed. Control-flow integrity (CFI) aims to be a generic solution to counteract control-flow hijacks. However, software-based CFI typically either protects against software or fault attacks, but not against both. While hardware-assisted CFI can mitigate both, they require hardware changes, which are unrealistic for existing architectures. Thus, a wide range of systems remains unprotected and vulnerable to control-flow attacks. This work presents FIPAC, a software-based CFI scheme protecting the execution at basic block granularity against software and fault attacks. FIPAC exploits ARM pointer authentication of ARMv8.6-A to implement a cryptographically signed control-flow graph. We cryptographically link the correct sequence of executed basic blocks to enforce CFI at this level. We use a custom LLVM-based toolchain to automatically instrument programs. The evaluation on SPEC2017 with different security policies shows a geometric mean code overhead between 51–91 % and a runtime overhead between 19–63 %. For embedded benchmarks, we measured geometric mean runtime overheads between 49–168 %. While these overheads are higher than for countermeasures against software attacks, FIPAC outperforms related work protecting the control-flow against faults. FIPAC is an efficient solution to protect software- and fault-based CFI attacks on basic block level on modern ARM devices.","tags":["Source Themes"],"title":"FIPAC: Thwarting Fault- and Software-Induced Control-Flow Attacks with ARM Pointer Authentication","type":"publication"},{"authors":["Pascal Nasahl","Robert Schilling","Stefan Mangard"],"categories":null,"content":"","date":1638489600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1638489600,"objectID":"d2c70436c0a72d46b6a9f505898195d2","permalink":"https://example.com/publication/15_pac_ibranch/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/publication/15_pac_ibranch/","section":"publication","summary":"With the growing number of embedded devices deployed in safety- and privacy-sensitive applications, such as in the automotive area or in the IoT, the hardening of these systems against attacks is getting essential. As these devices are physically accessible by an adversary, fault attacks are frequently used to hijack the control-flow of the executed program and bypass security defenses such as secure boot, gain arbitrary code execution, or retrieve sensitive information. To protect the control-flow from this threat, control-flow integrity (CFI) aims to be an effective and generic countermeasure. Although CFI aims to mitigate fault induced control-flow hijacking attacks, state-of-the-art CFI schemes do not protect addresses, allowing an attacker to still hijack the control-flow of indirect branches. To counteract this threat and detect unwanted bit flips, data encoding schemes are frequently used to add redundancy to these addresses. However, software-based data encoding schemes yield large runtime overheads, making them hard to deploy on a larger scale. To reduce this performance overhead, related work typically introduces custom CPU changes, which are not feasible for off-the-shelf systems, leaving a broad range of devices unprotected. Hence, software-based address redundancy schemes for commodity devices are needed to thwart fault attacks on indirect branches. In this paper, we utilize the ARM pointer authentication feature of recent ARM architectures to efficiently protect the target addresses of indirect calls. In addition to the address protection, we further enhance the state update function of existing CFI schemes to protect the link between indirect controlflow transfers. To demonstrate how these defense mechanisms improve the protection of state-of-the-art CFI countermeasures, we integrate our address encoding and linking strategy into a previously introduced CFI scheme. We further extend a LLVMbased toolchain to automatically thwart fault attacks on indirect branches without user interaction. Our analysis shows an negligible overhead of less than 2.34% on average for protecting target addresses of indirect branches and the link between indirect branches for SPEC2017.","tags":["Source Themes"],"title":"Protecting Indirect Branches Against Fault Attacks Using ARM Pointer Authentication","type":"publication"},{"authors":["Robert Schilling","Pascal Nasahl","Stefan Weiglhofer","Stefan Mangard"],"categories":null,"content":"","date":1638489600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1638489600,"objectID":"a14338dc561124c4cd28012f664bd1bc","permalink":"https://example.com/publication/12_secwalk/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/publication/12_secwalk/","section":"publication","summary":"The correct execution of a memory load and store is essential for the flawless execution of a program. However, as soon as devices are deployed in hostile environments, fault attacks can manipulate memory operations and subsequently alter the execution of a program. While memory accesses for simple processors with direct memory access can efficiently be protected against fault attacks, larger processors with virtual addressing lack this protection. However, the number of systems with larger application-class processors is growing, leaving many applications unprotected. It requires new countermeasures to efficiently protect memory accesses of application-class processors with virtual memory against fault attacks. In this work, we present SecWalk, a design to efficiently protect all memory accesses of a program in the virtual and physical memory domain against fault attacks. We enhance residual-based pointer protection with a hardware-based secure page table walk inside the memory management unit. The page table walk securely translates a protected virtual address to a protected physical address by exploiting the redundancy properties of encoded addresses and a linking mechanism in the memory management unit. Furthermore, we extend the protection domain for virtual addresses to the TLB to also protect fast translations. To evaluate the overhead of our design, we integrate SecWalk to an FPGA-based hardware implementation of an open-source RISC-V processor. The hardware evaluation shows that SecWalk extends the area of the design by 10 %. The software evaluation on a set of microbenchmarks shows an average code and runtime overhead of 11.05 %. To show the applicability on real-life applications, we port the microkernel seL4 to SecWalk, which yields a code overhead of 13.1 % and a runtime overhead of 11.6 %. This evaluation shows the overhead is small considering that SecWalk automatically protects all memory accesses of arbitrary applications against fault attacks.","tags":["Source Themes"],"title":"SecWalk: Protecting Page Table Walks Against Fault Attacks","type":"publication"},{"authors":["Pascal Nasahl","Robert Schilling","Mario Werner","Jan Hoogerbrugge","Marcel Medwed","Stefan Mangard"],"categories":null,"content":"","date":1620000000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620000000,"objectID":"ae4647aa32e9018299b698f95a8f9ac6","permalink":"https://example.com/publication/14_cryptag/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/publication/14_cryptag/","section":"publication","summary":"Memory vulnerabilities are a major threat to many computing systems. To effectively thwart spatial and temporal memory vulnerabilities, full logical memory safety is required. However, current mitigation techniques for memory safety are either too expensive or trade security against efficiency. One promising attempt to detect memory safety vulnerabilities in hardware is memory coloring, a security policy deployed on top of tagged memory architectures. However, due to the memory storage and bandwidth overhead of large tags, commodity tagged memory architectures usually only provide small tag sizes, thus limiting their use for security applications. Irrespective of logical memory safety, physical memory safety is a necessity in hostile environments prevalent for modern cloud computing and IoT devices. Architectures from Intel and AMD already implement transparent memory encryption to maintain confidentiality and integrity of all off-chip data. Surprisingly, the combination of both, logical and physical memory safety, has not yet been extensively studied in previous research, and a naïve combination of both security strategies would accumulate both overheads. In this paper, we propose CrypTag, an efficient hardware/software co-design mitigating a large class of logical memory safety issues and providing full physical memory safety. At its core, CrypTag utilizes a transparent memory encryption engine not only for physical memory safety, but also for memory coloring at hardly any additional costs. The design avoids any overhead for tag storage by embedding memory colors in the upper bits of a pointer and using these bits as an additional input for the memory encryption. A custom compiler extension automatically leverages CrypTag to detect logical memory safety issues for commodity programs and is fully backward compatible. For evaluating the design, we extended a RISC-V processor with memory encryption with CrypTag. Furthermore, we developed a LLVM-based toolchain automatically protecting all dynamic, local, and global data. Our evaluation shows a hardware overhead of less than 1 % and an average runtime overhead between 1.5 % and 6.1 % for thwarting logical memory safety vulnerabilities on a system already featuring memory encryption. Enhancing a system with memory encryption typically induces a runtime overhead between 5 % and 109.8 % for commercial and open-source encryption units.","tags":["Source Themes"],"title":"CrypTag: Thwarting Physical and Logical Memory Vulnerabilities using Cryptographically Colored Memory","type":"publication"},{"authors":["Pascal Nasahl","Robert Schilling","Mario Werner","Stefan Mangard"],"categories":null,"content":"","date":1620000000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1620000000,"objectID":"0a3a4aaa828ecea65306c2f68e8e3331","permalink":"https://example.com/publication/13_hectorv/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/publication/13_hectorv/","section":"publication","summary":"To ensure secure and trustworthy execution of applications in potentially insecure environments, vendors frequently embed trusted execution environments (TEE) into their systems. Applications executed in this safe, isolated space are protected from adversaries, including a malicious operating system. TEEs are usually build by integrating protection mechanisms directly into the processor or by using dedicated external secure elements. However, both of these approaches only cover a narrow threat model resulting in limited security guarantees. Enclaves nested into the application processor typically provide weak isolation between the secure and non-secure domain, especially when considering side-channel attacks. Although external secure elements do provide strong isolation, the slow communication interface to the application processor is exposed to adversaries and restricts the use cases. Independently of the used implementation approach, TEEs often lack the possibility to establish secure communication to external peripherals, and most operating systems executed inside TEEs do not provide state-of-the-art defense strategies, making them vulnerable against various attacks. We argue that TEEs, such as Intel SGX or ARM TrustZone, implemented on the main application processor, are insecure, especially when considering side-channel attacks. In this paper, we demonstrate how a heterogeneous multicore architecture can be utilized to realize a secure TEE design. We directly embed a secure processor into our HECTOR-V architecture to provide strong isolation between the secure and non-secure domain. The tight coupling of the TEE and the application processor enables HECTOR-V to provide mechanisms for establishing secure communication channels between different devices. We further introduce RISC-V Secure CoProcessor (RVSCP), a security-hardened processor tailored for TEEs. To secure applications executed inside the TEE, RVSCP provides hardware enforced control-flow integrity and rigorously restricts I/O accesses to certain execution states. RVSCP reduces the trusted computing base to a minimum by providing operating system services directly in hardware.","tags":["Source Themes"],"title":"HECTOR-V: A Heterogeneous CPU Architecture for a Secure RISC-V","type":"publication"},{"authors":["Michael Schwarz","Moritz Lipp","Claudio Canella","Robert Schilling","Florian Kargl","Daniel Gruss"],"categories":null,"content":"","date":1580688000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580688000,"objectID":"30f8d987973f918ef9b9b73f55800a29","permalink":"https://example.com/publication/11_context/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/publication/11_context/","section":"publication","summary":"Out-of-order execution and speculative execution are among the biggest contributors to performance and efficiency of modern processors. However, they are inconsiderate, leaking secret data during the transient execution of instructions. Many solutions and hardware fixes have been proposed for mitigating transient-execution attacks. However, they either do not eliminate the leakage entirely or introduce unacceptable performance penalties. In this paper, we propose ConTExT, a Considerate Transient Execution Technique. ConTExT is a minimal and fully backward compatible architecture change. The basic idea of ConTExT is that secrets can enter registers but not transiently leave them. ConTExT transforms Spectre from a problem that cannot be solved purely in software, to a problem that is not easy to solve, but solvable in software. For this, ConTExT requires minimal, fully backward-compatible modifications of applications, compilers, operating systems, and the hardware. ConTExT offers full protection for secrets in memory and secrets in registers. With ConTExT-light, we propose a software-only solution of ConTExT for existing commodity CPUs protecting secrets in memory. We evaluate the security and performance of ConTExT. Even when over-approximating with ConTExT-light, we observe no performance overhead for unprotected code and data, and an overhead between 0 % and 338 % for security-critical applications while protecting against all Spectre variants.","tags":["Source Themes"],"title":"ConTExT: A Generic Approach for Mitigating Spectre","type":"publication"},{"authors":["Mario Werner","Robert Schilling","Thomas Unterluggauer","Stefan Mangard"],"categories":null,"content":"","date":1551571200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551571200,"objectID":"23c325c10fb77a0ac44d3d307a4841d0","permalink":"https://example.com/publication/09_riscv_faults/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/publication/09_riscv_faults/","section":"publication","summary":"RISC-V is an emerging instruction-set architecture suitable for a wide variety of applications, which ranges from simple microcontrollers to high-performance CPUs. As an increasing number of commercial vendors now plans to adopt the architecture in their products, its security aspects are becoming a significant concern. For microcontroller implementations of RISC-V, one of the main security risks are attackers with direct physical access to the microchip. These physical attackers can perform highly powerful attacks that span from memory probing to power analysis up to fault injection and analysis. In this paper, we give an overview of the capabilities of attackers with direct physical device access, common threat models and attack vectors, and possible countermeasures. Besides, we discuss in more detail current approaches to secure RISC-V processors against fault injection attacks on the microchip itself. First, we show how to protect the control-flow against fault attacks by using an encrypted instruction stream and decrypting it on-thefly in a newly added pipeline stage between the processor’s fetch and decode unit. Second, we show how to protect conditional branches against fault injection by adding redundancy to the comparison operation and entangling the comparison result with the encrypted instruction stream. Finally, we discuss an approach to protect all pointers and memory accesses from tampering.","tags":["Source Themes"],"title":"Protecting RISC-V Processors against Physical Attacks","type":"publication"},{"authors":["Robert Schilling","Mario Werner","Stefan Mangard"],"categories":null,"content":"","date":1551571200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551571200,"objectID":"8304a2ccc4f6bd595e4507e66be66164","permalink":"https://example.com/publication/07_branches/","publishdate":"2018-04-27T00:00:00Z","relpermalink":"/publication/07_branches/","section":"publication","summary":"In typical software, many comparisons and subsequent branch operations are highly critical in terms of security. Examples include password checks, signature checks, secure boot, and user privilege checks. For embedded devices, these security-critical branches are a preferred target of fault attacks as a single bit flip or skipping a single instruction can lead to complete access to a system. In the past, numerous redundancy schemes have been proposed in order to provide controlflow-integrity (CFI) and to enable error detection on processed data. However, current countermeasures for general purpose software do not provide protection mechanisms for conditional branches. Hence, critical branches are in practice often simply duplicated. We present a generic approach to protect conditional branches, which links an encoding-based comparison result with the redundancy of CFI protection mechanisms. The presented approach can be used for all types of data encodings and CFI mechanisms and maintains their error-detection capabilities throughout all steps of a conditional branch. We demonstrate our approach by realizing an encoded comparison based on AN-codes, which is a frequently used encoding scheme to detect errors on data during arithmetic operations. We extended the LLVM compiler so that standard code and conditional branches can be protected automatically and analyze its security. Our design shows that the overhead in terms of size and runtime is lower than state-of-the-art duplication schemes.","tags":["Source Themes"],"title":"Securing Conditional Branches in the Presence of Fault Attacks","type":"publication"},{"authors":["Anja F. Karl","Robert Schilling","Roderick Bloem","Stefan Mangard"],"categories":null,"content":"","date":1547337600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547337600,"objectID":"f053771aec6db8130368318c9d98150b","permalink":"https://example.com/publication/10_faults_grow/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/publication/10_faults_grow/","section":"publication","summary":"The increasing prevalence of soft errors and security concerns due to recent attacks like rowhammer have caused increased interest in the robustness of software against bit flips. Arithmetic codes can be used as a protection mechanism to detect small errors injected in the program’s data. However, the accumulation of propagated errrors can increase the number of bits flips in a variable - possibly up to an undetectable level. The effect of error masking can occur: An error weight exceeds the limitations of the code and a new, valid, but incorrect code word is formed. Masked errors are undetectable, and it is crucial to check variables for bit flips before error masking can occur. In this paper, we develop a theory of provably robust arithmetic programs. We focus on the interaction of bit flips that can happen at different locations in the program and the propagation and possible masking of errors. We show how this interaction can be formally modeled and how off-the-shelf model checkers can be used to show correctness. We evaluate our approach based on prominent and security relevant algorithms and show that even multiple faults injected at any time into any variables can be handled by our method.","tags":["Source Themes"],"title":"Small Faults Grow Up - Verification of Error Masking Robustness in Arithmetically Encoded Programs","type":"publication"},{"authors":["Robert Schilling","Mario Werner","Pascal Nasahl","Stefan Mangard"],"categories":null,"content":"","date":1543795200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543795200,"objectID":"36176d08b5ef56fcd73b1752c44042a3","permalink":"https://example.com/publication/06_pointing/","publishdate":"2017-01-27T00:00:00Z","relpermalink":"/publication/06_pointing/","section":"publication","summary":"Reading and writing memory are, besides computation, the most common operations a processor performs. The correctness of these operations is therefore essential for the proper execution of any program. However, as soon as fault attacks are considered, assuming that the hardware performs its memory operations as instructed is not valid anymore. In particular, attackers may induce faults with the goal of reading or writing incorrectly addressed memory, which can have various critical safety and security implications. In this work, we present a solution to this problem and propose a new method for protecting every memory access inside a program against address tampering. The countermeasure comprises two building blocks. First, every pointer inside the program is redundantly encoded using a multi-residue error detection code. The redundancy information is stored in the unused upper bits of the pointer with zero overhead in terms of storage. Second, load and store instructions are extended to link data with the corresponding encoded address from the pointer. Wrong memory accesses subsequently infect the data value allowing the software to detect the error. For evaluation purposes, we implemented our countermeasure into a RISC-V processor, tested it on a FPGA development board, and evaluated the induced overhead. Furthermore, a LLVM-based C compiler has been modified to automatically encode all data pointers, to perform encoded pointer arithmetic, and to emit the extended load/store instructions with linking support. Our evaluations show that the countermeasure induces an average overhead of 10 % in terms of code size and 7 % regarding runtime, which makes it suitable for practical adoption.","tags":["Source Themes"],"title":"Pointing in the Right Direction - Securing Memory Accesses in a Faulty World","type":"publication"},{"authors":["Robert Schilling","Thomas Unterluggauer","Stefan Mangard","Frank K. Gürkaynak","Michael Muehlberghuber","Luca Benini"],"categories":null,"content":"","date":1522713600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1522713600,"objectID":"4d63e48acb5728728fc94d7a32ae5636","permalink":"https://example.com/publication/08_fulmine_lr/","publishdate":"2018-04-27T00:00:00Z","relpermalink":"/publication/08_fulmine_lr/","section":"publication","summary":"Embedded devices in the Internet-ofThings require encryption functionalities to secure their communication. However, side-channel attacks and in particular differential power analysis (DPA) attacks pose a serious threat to cryptographic implementations. While state-of-the-art countermeasures like masking slow down the performance and can only prevent DPA up to a certain order, leakage-resilient schemes are designed to stay secure even in the presence of side-channel leakage. Although several leakageresilient schemes have been proposed, there are no hardware implementations to demonstrate their practicality and performance on measurable silicon. In this work, we present an ASIC implementation of a multi-core System-on-Chip extended with a softwareprogrammable accelerator for leakage-resilient cryptography. The accelerator is deeply embedded in the shared memory architecture of the many-core system, supports different configurations, contains a highthroughput implementation of the 2PRG primitive based on AES-128, offers two side-channel protected rekeying functions, and is the first fabricated design of the side-channel secure authenticated encryption scheme ISAP. The accelerator reaches a maximum throughput of 7.49 Gbit/s and a best-case energy efficiency of 137 Gbit/s/W making this accelerator suitable for highspeed secure IoT applications.","tags":["Source Themes"],"title":"High Speed ASIC Implementations of Leakage-Resilient Cryptography","type":"publication"},{"authors":["Thomas Unterluggauer","Thomas Korak","Stefan Mangard","Robert Schilling","Luca Benini","Frank K. Gürkaynak","Michael Muehlberghuber"],"categories":null,"content":"","date":1510012800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1510012800,"objectID":"3262dbcfddddb2ca63407605f61ce772","permalink":"https://example.com/publication/03_leakage/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/03_leakage/","section":"publication","summary":"In recent years, many leakage-resilient schemes have been published. These schemes guarantee security against side-channel attacks given bounded leakage of the underlying primitive. However, it is a challenging task to reliably determine these leakage bounds from physical properties. In this work, we present a novel approach to find reliable leakage bounds for side channels of cryptographic implementations when the input data complexity is limited such as in leakage-resilient schemes. By mapping results from communication theory to the side-channel domain, we show that the channel capacity is the natural upper bound for the mutual information (MI) to be learned from multivariate side-channels with Gaussian noise. It shows that this upper bound is determined by the device-specific signal-to-noise ratio (SNR). We further investigate the case when attackers are capable of measuring the same side-channel leakage multiple times and perform signal averaging. Our results here indicate that the gain in the SNR obtained from averaging is exponential in the number of points of interest that are used from the leakage traces. Based on this, we illustrate how the side-channel capacity gives a tool to compute the minimum attack complexity to learn a certain amount of information from side-channel leakage. We then show that our MI bounds match with reality by evaluating the MI in multivariate Gaussian templates built from practical measurements on an ASIC. We finally use our model to show the security of the Keccak-f[400]-based authenticated encryption scheme Isap on this ASIC against power analysis attacks.","tags":["Source Themes"],"title":"Leakage Bounds for Gaussian Side Channels","type":"publication"},{"authors":["Francesco Conti","Robert Schilling","Pasquale Davide Schiavone","Antonio Pullini","Davide Rossi","Frank K. Gürkaynak","Michael Muehlberghuber","Michael Gautschi","Igor Loi","Germain Haugou","Stefan Mangard","Luca Benini"],"categories":null,"content":"","date":1506211200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1506211200,"objectID":"9196d14419d6df0ec4a6dc732bac03ed","permalink":"https://example.com/publication/05_fulmine_iot/","publishdate":"2017-01-27T00:00:00Z","relpermalink":"/publication/05_fulmine_iot/","section":"publication","summary":"Near-sensor data analytics is a promising direction for internet-of-things endpoints, as it minimizes energy spent on communication and reduces network load - but it also poses security concerns, as valuable data are stored or sent over the network at various stages of the analytics pipeline. Using encryption to protect sensitive data at the boundary of the on-chip analytics engine is a way to address data security issues. To cope with the combined workload of analytics and encryption in a tight power envelope, we propose Fulmine, a system-on-chip (SoC) based on a tightly-coupled multi-core cluster augmented with specialized blocks for compute-intensive data processing and encryption functions, supporting software programmability for regular computing tasks. The Fulmine SoC, fabricated in 65-nm technology, consumes less than 20mW on average at 0.8V achieving an efficiency of up to 70pJ/B in encryption, 50pJ/px in convolution, or up to 25MIPS/mW in software. As a strong argument for real-life flexible application of our platform, we show experimental results for three secure analytics use cases: secure autonomous aerial surveillance with a state-of-the-art deep convolutional neural network (CNN) consuming 3.16pJ per equivalent reduced instruction set computer operation, local CNN-based face detection with secured remote recognition in 5.74pJ/op, and seizure detection with encrypted data collection from electroencephalogram within 12.7pJ/op.","tags":["Source Themes"],"title":"An IoT Endpoint System-on-Chip for Secure and Energy-Efficient Near-Sensor Analytics","type":"publication"},{"authors":["Mario Werner","Thomas Unterluggauer","Robert Schilling","David Schaffenrath","Stefan Mangard"],"categories":null,"content":"","date":1504742400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1504742400,"objectID":"47b9448e5cac7046579c973a45c4ac33","permalink":"https://example.com/publication/02_memsec/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/02_memsec/","section":"publication","summary":"Security features of modern (SoC) FPGAs permit to protect the confidentiality of hard- and software IP when the devices are powered off as well as to validate the authenticity of IP when being loaded at startup. However, these approaches are insufficient since attackers with physical access can also perform attacks during runtime, demanding for additional security measures. In particular, RAM used by modern (SoC) FPGAs is under threat since RAM stores software IP as well as all kinds of other sensitive information during runtime. To solve this issue, we present an open-source framework for building transparent RAM encryption and authentication pipelines, suitable for both FPGAs and ASICs. The framework supports various ciphers and modes of operation as shown by our comprehensive evaluation on a Xilinx Zynq-7020 SoC. For encryption, the ciphers Prince and AES are used in the ECB, CBC and XTS mode. Additionally, the authenticated encryption cipher Ascon is used both standalone and within a TEC tree. Our results show that the data processing of our encryption pipeline is highly efficient with up to 94 % utilization of the read bandwidth that is provided by the FPGA interface. Moreover, the use of a cryptographically strong primitive like Ascon yields highly practical results with 54 % bandwidth utilization.","tags":["Source Themes"],"title":"Transparent Memory Encryption and Authentication","type":"publication"},{"authors":["Frank K. Gürkaynak","Robert Schilling","Michael Muehlberghuber","Francesco Conti","Stefan Mangard","Luca Benini"],"categories":null,"content":"","date":1485216000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1485216000,"objectID":"0a72d5dd00ea75a29c82f61b2b254f84","permalink":"https://example.com/publication/04_fulmine_xts/","publishdate":"2017-01-27T00:00:00Z","relpermalink":"/publication/04_fulmine_xts/","section":"publication","summary":"Embedded systems for Internet-of-Things applications present new challenges to system design. From a hardware design perspective, energy efficiency is paramount, as most of devices have a limited power supply due to size considerations. Transmitting data away from the node remains a very power hungry operation, and the only viable solution to this problem is to reduce the amount of data by performing pre-processing which again requires additional computational power. Hence modern embedded devices need to strike a fine balance between the power needed for acquisition/processing and communication. In many scenarios, small IoT devices will be deployed widely making them vulnerable to malicious attacks. Thus, for practical applications, these devices also need to fit the necessary resources to provide adequate security services. We present a cryptographic hardware accelerator capable of supporting multiple encryption and decryption modes for different cryptographic algorithms (AES, Keccak) in an energy efficient multi-core cluster optimized for embedded digital signal processing applications implemented in 65 nm CMOS technology. We show that it is possible to have the necessary computation power to perform cryptographic services in addition to state of the art processing in a power budget that is compatible with IoT devices in a mature 65 nm CMOS technology. When running at 0.8 V the SoC with the cryptographic accelerator can be clocked at 84 MHz running AES-XTS at more than 250 Mbits/s consuming a total of 27 mW, which is a 100 × gain in energy and 496 × gain in operation speed over an optimized software implementation running on a single 32 bit OpenRISC core.","tags":["Source Themes"],"title":"Multi-Core Data Analytics SoC with a Flexible 1.76 Gbit/s AES-XTS Cryptographic Accelerator in 65 nm CMOS","type":"publication"},{"authors":["Robert Schilling","Manuel Jelinek","Markus Ortoff","Thomas Unterluggauer"],"categories":null,"content":"","date":1415318400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1415318400,"objectID":"55fdae4c9d2d76b6f40b6866429b26e1","permalink":"https://example.com/publication/01_aegis/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/01_aegis/","section":"publication","summary":"Due to the lack of proper dedicated authenticated encryption algorithms, the CAESAR cryptographic competition aims to find new such algorithms. The goal of authenticated encryption is to provide both confidentiality and authenticity within a single algorithm. This paper introduces the first application-specific integrated circuit of AEGIS128, which is one promising submission to the CAESAR competition. The dedicated hardware design is optimized towards yielding the smallest area for AEGIS128. Using a 013 μm low-leakage process from Faraday Technology, the design requires merely 13,558 gate equivalents or 0.06942mm² . Simulations of this design at a clock frequency of 100MHz result in 65 Mbps data throughput.","tags":["Source Themes"],"title":"A Low-Area ASIC Implementation of AEGIS128—A fast Authenticated Encryption Algorithm","type":"publication"}]